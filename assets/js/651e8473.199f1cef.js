"use strict";(self.webpackChunkdev_portal_docsite=self.webpackChunkdev_portal_docsite||[]).push([[99884],{15680:(e,t,n)=>{n.d(t,{xA:()=>h,yg:()=>m});var i=n(96540);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},h=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),d=c(n),u=a,m=d["".concat(l,".").concat(u)]||d[u]||p[u]||o;return n?i.createElement(m,r(r({ref:t},h),{},{components:n})):i.createElement(m,r({ref:t},h))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:a,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},97755:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var i=n(58168),a=(n(96540),n(15680));const o={title:"Overview",sidebar_label:"Overview",sidebar_position:1,slug:"/ibc/light-clients/tendermint/overview"},r="07-tendermint",s={unversionedId:"docs/light-clients/tendermint/overview",id:"docs/light-clients/tendermint/overview",title:"Overview",description:"Overview",source:"@site/ibc-go/docs/03-light-clients/05-tendermint/01-overview.md",sourceDirName:"docs/03-light-clients/05-tendermint",slug:"/ibc/light-clients/tendermint/overview",permalink:"/dev-portal-docsite/ibc-go/next/ibc/light-clients/tendermint/overview",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Overview",sidebar_label:"Overview",sidebar_position:1,slug:"/ibc/light-clients/tendermint/overview"},sidebar:"defaultSidebar",previous:{title:"Migrations",permalink:"/dev-portal-docsite/ibc-go/next/ibc/light-clients/wasm/migrations"},next:{title:"Overview",permalink:"/dev-portal-docsite/ibc-go/next/middleware/callbacks/overview"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Initialization",id:"initialization",level:2},{value:"Updates",id:"updates",level:2},{value:"Proofs",id:"proofs",level:2},{value:"Misbehaviour",id:"misbehaviour",level:2},{value:"Security model",id:"security-model",level:3}],h={toc:c},d="wrapper";function p(e){let{components:t,...n}=e;return(0,a.yg)(d,(0,i.A)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"07-tendermint"},(0,a.yg)("inlineCode",{parentName:"h1"},"07-tendermint")),(0,a.yg)("h2",{id:"overview"},"Overview"),(0,a.yg)("admonition",{title:"Synopsis",type:"note"},(0,a.yg)("p",{parentName:"admonition"},"Learn about the 07-tendermint light client module.")),(0,a.yg)("p",null,"The Tendermint client is the first and most deployed light client in IBC. It implements the IBC ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/cosmos/ibc-go/blob/v9.0.0-beta.1/modules/core/exported/client.go#L41-L123"},"light client module interface")," to track a counterparty running ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/cometbft/cometbft"},"CometBFT")," consensus. "),(0,a.yg)("admonition",{type:"note"},(0,a.yg)("p",{parentName:"admonition"},"Tendermint is the old name of CometBFT which has been retained in IBC to avoid expensive migration costs.")),(0,a.yg)("p",null,"The Tendermint client consists of two important structs that keep track of the state of the counterparty chain and allow for future updates. The ",(0,a.yg)("inlineCode",{parentName:"p"},"ClientState")," struct contains all the parameters necessary for CometBFT header verification. The ",(0,a.yg)("inlineCode",{parentName:"p"},"ConsensusState"),", on the other hand, is a compressed view of a particular header of the counterparty chain. Unlike off chain light clients, IBC does not store full header. Instead it stores only the information it needs to prove verification of key/value pairs in the counterparty state (i.e. the header ",(0,a.yg)("inlineCode",{parentName:"p"},"AppHash"),"), and the information necessary to use the consensus state as the next root of trust to add a new consensus state to the client (i.e. the header ",(0,a.yg)("inlineCode",{parentName:"p"},"NextValidatorsHash")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"Timestamp"),"). The relayer provides the full trusted header on ",(0,a.yg)("inlineCode",{parentName:"p"},"UpdateClient"),", which will get checked against the compressed root-of-trust consensus state. If the trusted header matches a previous consensus state, and the trusted header and new header pass the CometBFT light client update algorithm, then the new header is compressed into a consensus state and added to the IBC client."),(0,a.yg)("p",null,"Each Tendermint Client is composed of a single ",(0,a.yg)("inlineCode",{parentName:"p"},"ClientState")," keyed on the client ID, and multiple consensus states which are keyed on both the clientID and header height. Relayers can use the consensus states to verify merkle proofs of packet commitments, acknowledgements, and receipts against the ",(0,a.yg)("inlineCode",{parentName:"p"},"AppHash")," of the counterparty chain in order to enable verified packet flow."),(0,a.yg)("p",null,"If a counterparty chain violates the CometBFT protocol in a way that is detectable to off-chain light clients, this misbehaviour can also be submitted to an IBC client by any off-chain actor. Upon verification of this misbehaviour, the Tendermint IBC Client will freeze, preventing any further packet flow from this malicious chain from occurring. Governance or some other out-of-band protocol may then be used to unwind any damage that has already occurred."),(0,a.yg)("h2",{id:"initialization"},"Initialization"),(0,a.yg)("p",null,"The Tendermint light client is initialized with a ",(0,a.yg)("inlineCode",{parentName:"p"},"ClientState")," that contains parameters necessary for CometBFT header verification along with a latest height and ",(0,a.yg)("inlineCode",{parentName:"p"},"ConsensusState")," that encapsulates the application state root of a trusted header that will serve to verify future incoming headers from the counterparty."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-proto"},'message ClientState {\n  // human readable chain-id that will be included in header\n  // and signed over by the validator set\n  string   chain_id    = 1;\n  // trust level is the fraction of the trusted validator set\n  // that must sign over a new untrusted header before it is accepted\n  // it can be a minimum of 1/3 and a maximum of 2/3\n  // Note these are the bounds of liveness. 1/3 is the minimum \n  // honest stake needed to maintain liveness on a chain,\n  // requiring more than 2/3 to sign over the new header would\n  // break the BFT threshold of allowing 1/3 malicious validators\n  Fraction trust_level = 2;\n  // duration of the period since the LatestTimestamp during which the\n  // submitted headers are valid for update\n  google.protobuf.Duration trusting_period = 3;\n  // duration of the staking unbonding period\n  google.protobuf.Duration unbonding_period = 4;\n  // defines how much new (untrusted) header\'s Time can drift \n  // into the future relative to our local clock.\n  google.protobuf.Duration max_clock_drift = 5;\n\n  // Block height when the client was frozen due to a misbehaviour\n  ibc.core.client.v1.Height frozen_height = 6;\n  // Latest height the client was updated to\n  ibc.core.client.v1.Height latest_height = 7;\n\n  // Proof specifications used in verifying counterparty state\n  repeated cosmos.ics23.v1.ProofSpec proof_specs = 8;\n\n  // Path at which next upgraded client will be committed.\n  // Each element corresponds to the key for a single CommitmentProof in the\n  // chained proof. NOTE: ClientState must stored under\n  // `{upgradePath}/{upgradeHeight}/clientState` ConsensusState must be stored\n  // under `{upgradepath}/{upgradeHeight}/consensusState` For SDK chains using\n  // the default upgrade module, upgrade_path should be []string{"upgrade",\n  // "upgradedIBCState"}`\n  repeated string upgrade_path = 9;\n}\n')),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-proto"},"message ConsensusState {\n  // timestamp that corresponds to the block height in which the ConsensusState\n  // was stored.\n  google.protobuf.Timestamp timestamp = 1;\n  // commitment root (i.e app hash) that will be used\n  // to verify proofs of packet flow messages\n  ibc.core.commitment.v1.MerkleRoot root = 2;\n  // hash of the next validator set that will be used as\n  // a new updated source of trust to verify future updates\n  bytes next_validators_hash = 3;\n}\n")),(0,a.yg)("h2",{id:"updates"},"Updates"),(0,a.yg)("p",null,"Once the initial client state and consensus state are submitted, future consensus states can be added to the client by submitting IBC ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/cosmos/ibc-go/blob/v9.0.0-beta.1/proto/ibc/lightclients/tendermint/v1/tendermint.proto#L76-L94"},"headers"),". These headers contain all necessary information to run the CometBFT light client protocol."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-proto"},"message Header {\n  // this is the new signed header that we want to add\n  // as a new consensus state to the ibc client. \n  // the signed header contains the commit signatures of the `validator_set` below\n  .tendermint.types.SignedHeader signed_header = 1;\n\n  // the validator set which signed the new header\n  .tendermint.types.ValidatorSet validator_set      = 2;\n  // the trusted height of the consensus state which we are updating from\n  ibc.core.client.v1.Height      trusted_height     = 3;\n  // the trusted validator set, the hash of the trusted validators must be equal to \n  // `next_validators_hash` of the current consensus state\n  .tendermint.types.ValidatorSet trusted_validators = 4;\n}\n")),(0,a.yg)("p",null,"For detailed information on the CometBFT light client protocol and its safety properties please refer to the ",(0,a.yg)("a",{parentName:"p",href:"https://arxiv.org/abs/1807.04938"},"original Tendermint whitepaper"),"."),(0,a.yg)("h2",{id:"proofs"},"Proofs"),(0,a.yg)("p",null,"As consensus states are added to the client, they can be used for proof verification by relayers wishing to prove packet flow messages against a particular height on the counterparty. This uses the ",(0,a.yg)("inlineCode",{parentName:"p"},"VerifyMembership")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"VerifyNonMembership")," methods on the Tendermint client."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"// VerifyMembership is a generic proof verification method\n//which verifies a proof of the existence of a value at a \n// given CommitmentPath at the specified height. The caller\n// is expected to construct the full CommitmentPath from a \n// CommitmentPrefix and a standardized path (as defined in ICS 24).\nVerifyMembership(\n    ctx sdk.Context,\n    clientID string,\n    height Height,\n    delayTimePeriod uint64,\n    delayBlockPeriod uint64,\n    proof []byte,\n    path Path,\n    value []byte,\n) error\n\n// VerifyNonMembership is a generic proof verification method \n// which verifies the absence of a given CommitmentPath at a \n// specified height. The caller is expected to construct the \n// full CommitmentPath from a CommitmentPrefix and a standardized\n// path (as defined in ICS 24).\nVerifyNonMembership(\n    ctx sdk.Context,\n    clientID string,\n    height Height,\n    delayTimePeriod uint64,\n    delayBlockPeriod uint64,\n    proof []byte,\n    path Path,\n) error\n")),(0,a.yg)("p",null,"The Tendermint client is initialized with an ICS23 proof spec. This allows the Tendermint implementation to support many different merkle tree structures so long as they can be represented in an ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/cosmos/ics23/blob/go/v0.10.0/proto/cosmos/ics23/v1/proofs.proto#L145-L170"},(0,a.yg)("inlineCode",{parentName:"a"},"ics23.ProofSpec")),"."),(0,a.yg)("h2",{id:"misbehaviour"},"Misbehaviour"),(0,a.yg)("p",null,"The Tendermint light client directly tracks consensus of a CometBFT counterparty chain. So long as the counterparty is Byzantine Fault Tolerant, that is to say, the malicious subset of the bonded validators does not exceed the trust level of the client, then the client is secure."),(0,a.yg)("p",null,"In case the malicious subset of the validators exceeds the trust level of the client, then the client can be deceived into accepting invalid blocks and the connection is no longer secure."),(0,a.yg)("p",null,"The Tendermint client has some mitigations in place to prevent this. If there are two valid blocks signed by the counterparty validator set at the same height ","[e.g. a valid block signed by an honest subset and an invalid block signed by a malicious one]",", then these conflicting headers can be submitted to the client as ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/cosmos/ibc-go/blob/v9.0.0-beta.1/proto/ibc/lightclients/tendermint/v1/tendermint.proto#L65-L74"},"misbehaviour"),". The client will verify the headers and freeze the client; preventing any future updates and proof verification from succeeding. This effectively halts communication with the compromised counterparty while out-of-band social consensus can unwind any damage done."),(0,a.yg)("p",null,"Similarly, if the timestamps of the headers are not monotonically increasing, this can also be evidence of malicious behaviour and cause the client to freeze."),(0,a.yg)("p",null,"Thus, any consensus faults that are detectable by a light client are part of the misbehaviour protocol and can be used to minimize the damage caused by a compromised counterparty chain."),(0,a.yg)("h3",{id:"security-model"},"Security model"),(0,a.yg)("p",null,"It is important to note that IBC is not a completely trustless protocol; it is ",(0,a.yg)("strong",{parentName:"p"},"trust-minimized"),". This means that the safety property of bilateral IBC communication between two chains is dependent on the safety properties of the two chains in question. If one of the chains is compromised completely, then the IBC connection to the other chain is liable to receive invalid packets from the malicious chain. For example, if a malicious validator set has taken over more than 2/3 of the validator power on a chain; that malicious validator set can create a single chain of blocks with arbitrary commitment roots and arbitrary commitments to the next validator set. This would seize complete control of the chain and prevent the honest subset from even being able to create a competing honest block."),(0,a.yg)("p",null,"In this case, there is no ability for the IBC Tendermint client solely tracking CometBFT consensus to detect the misbehaviour and freeze the client. The IBC protocol would require out-of-band mechanisms to detect and fix such an egregious safety fault on the counterparty chain. Since the Tendermint light client is only tracking consensus and not also verifying the validity of state transitions, malicious behaviour from a validator set that is beyond the BFT fault threshold is an accepted risk of this light client implementation."),(0,a.yg)("p",null,"The IBC protocol has principles of fault isolation (e.g. all tokens are prefixed by their channel, so tokens from different chains are not mutually fungible) and fault mitigation (e.g. ability to freeze the client if misbehaviour can be detected before complete malicious takeover) that make this risk as minimal as possible."))}p.isMDXComponent=!0}}]);