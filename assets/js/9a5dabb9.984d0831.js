"use strict";(self.webpackChunkdev_portal_docsite=self.webpackChunkdev_portal_docsite||[]).push([[20324],{15680:(e,o,t)=>{t.d(o,{xA:()=>m,yg:()=>h});var s=t(96540);function a(e,o,t){return o in e?Object.defineProperty(e,o,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[o]=t,e}function n(e,o){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);o&&(s=s.filter((function(o){return Object.getOwnPropertyDescriptor(e,o).enumerable}))),t.push.apply(t,s)}return t}function i(e){for(var o=1;o<arguments.length;o++){var t=null!=arguments[o]?arguments[o]:{};o%2?n(Object(t),!0).forEach((function(o){a(e,o,t[o])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):n(Object(t)).forEach((function(o){Object.defineProperty(e,o,Object.getOwnPropertyDescriptor(t,o))}))}return e}function r(e,o){if(null==e)return{};var t,s,a=function(e,o){if(null==e)return{};var t,s,a={},n=Object.keys(e);for(s=0;s<n.length;s++)t=n[s],o.indexOf(t)>=0||(a[t]=e[t]);return a}(e,o);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(s=0;s<n.length;s++)t=n[s],o.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=s.createContext({}),d=function(e){var o=s.useContext(l),t=o;return e&&(t="function"==typeof e?e(o):i(i({},o),e)),t},m=function(e){var o=d(e.components);return s.createElement(l.Provider,{value:o},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var o=e.children;return s.createElement(s.Fragment,{},o)}},c=s.forwardRef((function(e,o){var t=e.components,a=e.mdxType,n=e.originalType,l=e.parentName,m=r(e,["components","mdxType","originalType","parentName"]),p=d(t),c=a,h=p["".concat(l,".").concat(c)]||p[c]||u[c]||n;return t?s.createElement(h,i(i({ref:o},m),{},{components:t})):s.createElement(h,i({ref:o},m))}));function h(e,o){var t=arguments,a=o&&o.mdxType;if("string"==typeof e||a){var n=t.length,i=new Array(n);i[0]=c;var r={};for(var l in o)hasOwnProperty.call(o,l)&&(r[l]=o[l]);r.originalType=e,r[p]="string"==typeof e?e:a,i[1]=r;for(var d=2;d<n;d++)i[d]=t[d];return s.createElement.apply(null,i)}return s.createElement.apply(null,t)}c.displayName="MDXCreateElement"},85022:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>n,metadata:()=>r,toc:()=>d});var s=t(58168),a=(t(96540),t(15680));const n={sidebar_position:1},i="Introduction to Cosmos SDK Modules",r={unversionedId:"build/building-modules/intro",id:"version-0.52/build/building-modules/intro",title:"Introduction to Cosmos SDK Modules",description:"Modules define most of the logic of Cosmos SDK applications. Developers compose modules together using the Cosmos SDK to build their custom application-specific blockchains. This document outlines the basic concepts behind SDK modules and how to approach module management.",source:"@site/cosmos-sdk_versioned_docs/version-0.52/build/building-modules/00-intro.md",sourceDirName:"build/building-modules",slug:"/build/building-modules/intro",permalink:"/dev-portal-docsite/cosmos-sdk/build/building-modules/intro",draft:!1,tags:[],version:"0.52",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"buildSidebar",previous:{title:"The Cosmos Security Handbook: Part 1 - Core Chain",permalink:"/dev-portal-docsite/cosmos-sdk/build/building-apps/security-part-1"},next:{title:"Module Manager",permalink:"/dev-portal-docsite/cosmos-sdk/build/building-modules/module-manager"}},l={},d=[{value:"Role of Modules in a Cosmos SDK Application",id:"role-of-modules-in-a-cosmos-sdk-application",level:2},{value:"Modules as super-users",id:"modules-as-super-users",level:3},{value:"How to Approach Building Modules as a Developer",id:"how-to-approach-building-modules-as-a-developer",level:2},{value:"Core APIs for Modules",id:"core-apis-for-modules",level:2},{value:"Main Components of Cosmos SDK Modules",id:"main-components-of-cosmos-sdk-modules",level:2}],m={toc:d},p="wrapper";function u(e){let{components:o,...t}=e;return(0,a.yg)(p,(0,s.A)({},m,t,{components:o,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"introduction-to-cosmos-sdk-modules"},"Introduction to Cosmos SDK Modules"),(0,a.yg)("admonition",{title:"Synopsis",type:"note"},(0,a.yg)("p",{parentName:"admonition"},"Modules define most of the logic of Cosmos SDK applications. Developers compose modules together using the Cosmos SDK to build their custom application-specific blockchains. This document outlines the basic concepts behind SDK modules and how to approach module management.")),(0,a.yg)("admonition",{title:"Pre-requisite Readings",type:"note"},(0,a.yg)("ul",{parentName:"admonition"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"/dev-portal-docsite/cosmos-sdk/learn/beginner/app-anatomy"},"Anatomy of a Cosmos SDK application")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"/dev-portal-docsite/cosmos-sdk/learn/beginner/tx-lifecycle"},"Lifecycle of a Cosmos SDK transaction")))),(0,a.yg)("h2",{id:"role-of-modules-in-a-cosmos-sdk-application"},"Role of Modules in a Cosmos SDK Application"),(0,a.yg)("p",null,"The Cosmos SDK can be thought of as the Next.js or Ruby-on-Rails of blockchain development. It comes with a core that provides the basic functionalities every blockchain application needs, like a ",(0,a.yg)("a",{parentName:"p",href:"/dev-portal-docsite/cosmos-sdk/learn/advanced/baseapp"},"boilerplate implementation of the ABCI")," to communicate with the underlying consensus engine, a ",(0,a.yg)("a",{parentName:"p",href:"/dev-portal-docsite/cosmos-sdk/learn/advanced/store#multistore"},(0,a.yg)("inlineCode",{parentName:"a"},"multistore"))," to persist state, a ",(0,a.yg)("a",{parentName:"p",href:"/dev-portal-docsite/cosmos-sdk/learn/advanced/node"},"server")," to form a full-node and ",(0,a.yg)("a",{parentName:"p",href:"/dev-portal-docsite/cosmos-sdk/build/building-modules/module-interfaces"},"interfaces")," to handle queries."),(0,a.yg)("p",null,"On top of this core, the Cosmos SDK enables developers to build modules that implement the business logic of their application. In other words, SDK modules implement the bulk of the logic of applications, while the core does the wiring (via ",(0,a.yg)("a",{parentName:"p",href:"/dev-portal-docsite/cosmos-sdk/build/building-apps/runtime"},"runtime"),") and enables modules to be composed together. The end goal is to build a robust ecosystem of open-source Cosmos SDK modules, making it increasingly easier to build complex blockchain applications."),(0,a.yg)("p",null,"Cosmos SDK modules can be seen as little state-machines within the state-machine. They generally define a subset of the state using one or more ",(0,a.yg)("inlineCode",{parentName:"p"},"KVStore"),"s in the ",(0,a.yg)("a",{parentName:"p",href:"/dev-portal-docsite/cosmos-sdk/learn/advanced/store"},"main multistore"),", as well as a subset of ",(0,a.yg)("a",{parentName:"p",href:"/dev-portal-docsite/cosmos-sdk/build/building-modules/messages-and-queries#messages"},"message types"),". These messages are routed by one of the main components of Cosmos SDK core, ",(0,a.yg)("a",{parentName:"p",href:"/dev-portal-docsite/cosmos-sdk/learn/advanced/baseapp"},(0,a.yg)("inlineCode",{parentName:"a"},"BaseApp")),", to a module Protobuf ",(0,a.yg)("a",{parentName:"p",href:"/dev-portal-docsite/cosmos-sdk/build/building-modules/msg-services"},(0,a.yg)("inlineCode",{parentName:"a"},"Msg")," service")," that defines them."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-mermaid"},'flowchart TD\n    A[Transaction relayed from the full-node\'s consensus engine to the node\'s application via DeliverTx]\n    A --\x3e B[APPLICATION]\n    B --\x3e C["Using baseapp\'s methods: Decode the Tx, extract and route the message(s)"]\n    C --\x3e D[Message routed to the correct module to be processed]\n    D --\x3e E[AUTH MODULE]\n    D --\x3e F[BANK MODULE]\n    D --\x3e G[STAKING MODULE]\n    D --\x3e H[GOV MODULE]\n    H --\x3e I[Handles message, Updates state]\n    E --\x3e I\n    F --\x3e I\n    G --\x3e I\n    I --\x3e J["Return result to the underlying consensus engine (e.g. CometBFT) (0=Ok, 1=Err)"]\n')),(0,a.yg)("p",null,"As a result of this architecture, building a Cosmos SDK application usually revolves around writing modules to implement the specialized logic of the application and composing them with existing modules to complete the application. Developers will generally work on modules that implement logic needed for their specific use case that do not exist yet, and will use existing modules for more generic functionalities like staking, accounts, or token management."),(0,a.yg)("h3",{id:"modules-as-super-users"},"Modules as super-users"),(0,a.yg)("p",null,"Modules have the ability to perform actions that are not available to regular users. This is because modules are given sudo permissions by the state machine. Modules can reject another modules desire to execute a function but this logic must be explicit. Examples of this can be seen when modules create functions to modify parameters:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go",metastring:"reference",reference:!0},"https://github.com/cosmos/cosmos-sdk/blob/61da5d1c29c16a1eb5bb5488719fde604ec07b10/x/bank/keeper/msg_server.go#L147-L149\n")),(0,a.yg)("h2",{id:"how-to-approach-building-modules-as-a-developer"},"How to Approach Building Modules as a Developer"),(0,a.yg)("p",null,"While there are no definitive guidelines for writing modules, here are some important design principles developers should keep in mind when building them:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Composability"),": Cosmos SDK applications are almost always composed of multiple modules. This means developers need to carefully consider the integration of their module not only with the core of the Cosmos SDK, but also with other modules. The former is achieved by following standard design patterns outlined ",(0,a.yg)("a",{parentName:"li",href:"#main-components-of-cosmos-sdk-modules"},"here"),", while the latter is achieved by properly exposing the store(s) of the module via the ",(0,a.yg)("a",{parentName:"li",href:"/dev-portal-docsite/cosmos-sdk/build/building-modules/keeper"},(0,a.yg)("inlineCode",{parentName:"a"},"keeper")),"."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Specialization"),": A direct consequence of the ",(0,a.yg)("strong",{parentName:"li"},"composability")," feature is that modules should be ",(0,a.yg)("strong",{parentName:"li"},"specialized"),". Developers should carefully establish the scope of their module and not batch multiple functionalities into the same module. This separation of concerns enables modules to be re-used in other projects and improves the upgradability of the application. ",(0,a.yg)("strong",{parentName:"li"},"Specialization")," also plays an important role in the ",(0,a.yg)("a",{parentName:"li",href:"https://docs.cosmos.network/main/learn/advanced/ocap#ocaps-in-practice"},"object-capabilities model")," of the Cosmos SDK."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Capabilities"),": Most modules need to read and/or write to the store(s) of other modules. However, in an open-source environment, it is possible for some modules to be malicious. That is why module developers need to carefully think not only about how their module interacts with other modules, but also about how to give access to the module's store(s). The Cosmos SDK takes a capabilities-oriented approach to inter-module security. This means that each store defined by a module is accessed by a ",(0,a.yg)("inlineCode",{parentName:"li"},"key"),", which is held by the module's ",(0,a.yg)("a",{parentName:"li",href:"/dev-portal-docsite/cosmos-sdk/build/building-modules/keeper"},(0,a.yg)("inlineCode",{parentName:"a"},"keeper")),". This ",(0,a.yg)("inlineCode",{parentName:"li"},"keeper")," defines how to access the store(s) and under what conditions. Access to the module's store(s) is done by passing a reference to the module's ",(0,a.yg)("inlineCode",{parentName:"li"},"keeper"),".")),(0,a.yg)("h2",{id:"core-apis-for-modules"},"Core APIs for Modules"),(0,a.yg)("p",null,"The SDK provides a set of APIs that a module can implement, and a set of services that a module can use.\nThose APIs are defined in the ",(0,a.yg)("inlineCode",{parentName:"p"},"cosmossdk.io/core/appmodule")," package, and are used to defined the module capabilities, which is used by ",(0,a.yg)("inlineCode",{parentName:"p"},"runtime")," during the wiring of the application. "),(0,a.yg)("p",null,"Whenever possible, a module should strive to use only the core APIs (",(0,a.yg)("inlineCode",{parentName:"p"},"cosmossdk.io/core"),") and not import the ",(0,a.yg)("inlineCode",{parentName:"p"},"github.com/cosmos/cosmos-sdk")," module. This makes modules reusable across SDK versions and reduces the risk of breaking changes."),(0,a.yg)("p",null,"Learn more about the core APIs for modules ",(0,a.yg)("a",{parentName:"p",href:"/dev-portal-docsite/cosmos-sdk/learn/advanced/core"},"here"),"."),(0,a.yg)("h2",{id:"main-components-of-cosmos-sdk-modules"},"Main Components of Cosmos SDK Modules"),(0,a.yg)("p",null,"Modules are by convention defined in the ",(0,a.yg)("inlineCode",{parentName:"p"},"./x/")," subfolder (e.g. the ",(0,a.yg)("inlineCode",{parentName:"p"},"bank")," module will be defined in the ",(0,a.yg)("inlineCode",{parentName:"p"},"./x/bank")," folder). They generally share the same core components:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"A ",(0,a.yg)("a",{parentName:"li",href:"/dev-portal-docsite/cosmos-sdk/build/building-modules/keeper"},(0,a.yg)("inlineCode",{parentName:"a"},"keeper")),", used to access the module's store(s) and update the state."),(0,a.yg)("li",{parentName:"ul"},"A ",(0,a.yg)("a",{parentName:"li",href:"/dev-portal-docsite/cosmos-sdk/build/building-modules/messages-and-queries#messages"},(0,a.yg)("inlineCode",{parentName:"a"},"Msg")," service"),", used to process messages when they are routed to the module by ",(0,a.yg)("a",{parentName:"li",href:"/dev-portal-docsite/cosmos-sdk/learn/advanced/baseapp#message-routing"},(0,a.yg)("inlineCode",{parentName:"a"},"BaseApp"))," and trigger state-transitions."),(0,a.yg)("li",{parentName:"ul"},"A ",(0,a.yg)("a",{parentName:"li",href:"/dev-portal-docsite/cosmos-sdk/build/building-modules/query-services"},"query service"),", used to process user queries when they are routed to the module by ",(0,a.yg)("a",{parentName:"li",href:"/dev-portal-docsite/cosmos-sdk/learn/advanced/baseapp#query-routing"},(0,a.yg)("inlineCode",{parentName:"a"},"BaseApp")),"."),(0,a.yg)("li",{parentName:"ul"},"Interfaces, for end users to query the subset of the state defined by the module and create ",(0,a.yg)("inlineCode",{parentName:"li"},"message"),"s of the custom types defined in the module.")),(0,a.yg)("p",null,"In addition to these components, modules implement the ",(0,a.yg)("inlineCode",{parentName:"p"},"AppModule")," interface in order to be managed by the ",(0,a.yg)("a",{parentName:"p",href:"/dev-portal-docsite/cosmos-sdk/build/building-modules/module-manager"},(0,a.yg)("inlineCode",{parentName:"a"},"module manager")),"."),(0,a.yg)("p",null,"Please refer to the ",(0,a.yg)("a",{parentName:"p",href:"/dev-portal-docsite/cosmos-sdk/build/building-modules/structure"},"structure document")," to learn about the recommended structure of a module's directory."))}u.isMDXComponent=!0}}]);