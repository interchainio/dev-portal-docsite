"use strict";(self.webpackChunkdev_portal_docsite=self.webpackChunkdev_portal_docsite||[]).push([[97395],{15680:(e,n,t)=>{t.d(n,{xA:()=>p,yg:()=>g});var i=t(96540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var r=i.createContext({}),c=function(e){var n=i.useContext(r),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},p=function(e){var n=c(e.components);return i.createElement(r.Provider,{value:n},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},m=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=c(t),m=a,g=h["".concat(r,".").concat(m)]||h[m]||d[m]||o;return t?i.createElement(g,l(l({ref:n},p),{},{components:t})):i.createElement(g,l({ref:n},p))}));function g(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,l=new Array(o);l[0]=m;var s={};for(var r in n)hasOwnProperty.call(n,r)&&(s[r]=n[r]);s.originalType=e,s[h]="string"==typeof e?e:a,l[1]=s;for(var c=2;c<o;c++)l[c]=t[c];return i.createElement.apply(null,l)}return i.createElement.apply(null,t)}m.displayName="MDXCreateElement"},86051:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var i=t(58168),a=(t(96540),t(15680));const o={title:"Overview",sidebar_label:"Overview",sidebar_position:1,slug:"/ibc/overview"},l="Overview",s={unversionedId:"docs/ibc/overview",id:"docs/ibc/overview",title:"Overview",description:"Learn about IBC, its components, and its use cases.",source:"@site/ibc-go/docs/01-ibc/01-overview.md",sourceDirName:"docs/01-ibc",slug:"/ibc/overview",permalink:"/dev-portal-docsite/ibc-go/next/ibc/overview",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Overview",sidebar_label:"Overview",sidebar_position:1,slug:"/ibc/overview"},sidebar:"defaultSidebar",previous:{title:"IBC-Go Documentation",permalink:"/dev-portal-docsite/ibc-go/next/"},next:{title:"Integration",permalink:"/dev-portal-docsite/ibc-go/next/ibc/integration"}},r={},c=[{value:"What is the Inter-Blockchain Communication Protocol (IBC)?",id:"what-is-the-inter-blockchain-communication-protocol-ibc",level:2},{value:"Components overview",id:"components-overview",level:2},{value:"Clients",id:"clients",level:3},{value:"IBC client heights",id:"ibc-client-heights",level:3},{value:"Connections",id:"connections",level:3},{value:"Time delayed connections",id:"time-delayed-connections",level:4},{value:"Proofs and paths",id:"proofs-and-paths",level:3},{value:"Ports",id:"ports",level:3},{value:"Channels",id:"channels",level:3},{value:"Closing channels",id:"closing-channels",level:4},{value:"Packets",id:"packets",level:3},{value:"Receipts and timeouts",id:"receipts-and-timeouts",level:3},{value:"Acknowledgments",id:"acknowledgments",level:3},{value:"Further readings and specs",id:"further-readings-and-specs",level:2}],p={toc:c},h="wrapper";function d(e){let{components:n,...t}=e;return(0,a.yg)(h,(0,i.A)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"overview"},"Overview"),(0,a.yg)("admonition",{title:"Synopsis",type:"note"},(0,a.yg)("p",{parentName:"admonition"},"Learn about IBC, its components, and its use cases.")),(0,a.yg)("h2",{id:"what-is-the-inter-blockchain-communication-protocol-ibc"},"What is the Inter-Blockchain Communication Protocol (IBC)?"),(0,a.yg)("p",null,"This document serves as a guide for developers who want to write their own Inter-Blockchain\nCommunication Protocol (IBC) applications for custom use cases."),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},"IBC applications must be written as self-contained modules.")),(0,a.yg)("p",null,"Due to the modular design of the IBC Protocol, IBC\napplication developers do not need to be concerned with the low-level details of clients,\nconnections, and proof verification."),(0,a.yg)("p",null,"This brief explanation of the lower levels of the\nstack gives application developers a broad understanding of the IBC\nProtocol. Abstraction layer details for channels and ports are most relevant for application developers and describe how to define custom packets and ",(0,a.yg)("inlineCode",{parentName:"p"},"IBCModule")," callbacks."),(0,a.yg)("p",null,"The requirements to have your module interact over IBC are:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Bind to a port or ports."),(0,a.yg)("li",{parentName:"ul"},"Define your packet data."),(0,a.yg)("li",{parentName:"ul"},"Use the default acknowledgment struct provided by core IBC or optionally define a custom acknowledgment struct."),(0,a.yg)("li",{parentName:"ul"},"Standardize an encoding of the packet data."),(0,a.yg)("li",{parentName:"ul"},"Implement the ",(0,a.yg)("inlineCode",{parentName:"li"},"IBCModule")," interface."),(0,a.yg)("li",{parentName:"ul"},"Implement the ",(0,a.yg)("inlineCode",{parentName:"li"},"UpgradableModule")," interface (optional).")),(0,a.yg)("p",null,"Read on for a detailed explanation of how to write a self-contained IBC application module."),(0,a.yg)("h2",{id:"components-overview"},"Components overview"),(0,a.yg)("h3",{id:"clients"},(0,a.yg)("a",{parentName:"h3",href:"https://github.com/cosmos/ibc-go/blob/main/modules/core/02-client"},"Clients")),(0,a.yg)("p",null,"IBC clients are on-chain light clients. Each light client is identified by a unique client ID.\nIBC clients track the consensus states of other blockchains, along with the proof spec necessary to\nproperly verify proofs against the client's consensus state. A client can be associated with any number\nof connections to the counterparty chain. The client identifier is auto generated using the client type\nand the global client counter appended in the format: ",(0,a.yg)("inlineCode",{parentName:"p"},"{client-type}-{N}"),"."),(0,a.yg)("p",null,"A ",(0,a.yg)("inlineCode",{parentName:"p"},"ClientState")," should contain chain specific and light client specific information necessary for verifying updates\nand upgrades to the IBC client. The ",(0,a.yg)("inlineCode",{parentName:"p"},"ClientState")," may contain information such as chain ID, latest height, proof specs,\nunbonding periods or the status of the light client. The ",(0,a.yg)("inlineCode",{parentName:"p"},"ClientState")," should not contain information that\nis specific to a given block at a certain height, this is the function of the ",(0,a.yg)("inlineCode",{parentName:"p"},"ConsensusState"),". Each ",(0,a.yg)("inlineCode",{parentName:"p"},"ConsensusState"),"\nshould be associated with a unique block and should be referenced using a height. IBC clients are given a\nclient identifier prefixed store to store their associated client state and consensus states along with\nany metadata associated with the consensus states. Consensus states are stored using their associated height."),(0,a.yg)("p",null,"The supported IBC clients are:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"https://github.com/cosmos/ibc-go/blob/main/modules/light-clients/06-solomachine"},"Solo Machine light client"),": Devices such as phones, browsers, or laptops."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"https://github.com/cosmos/ibc-go/blob/main/modules/light-clients/07-tendermint"},"Tendermint light client"),": The default for Cosmos SDK-based chains."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"https://github.com/cosmos/ibc-go/blob/main/modules/light-clients/08-wasm"},"Wasm client"),": Proxy client useful for running light clients written in a Wasm-compilable language."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"https://github.com/cosmos/ibc-go/blob/main/modules/light-clients/09-localhost"},"Localhost (loopback) client"),": Useful for testing, simulation, and relaying packets to modules on the same application.")),(0,a.yg)("h3",{id:"ibc-client-heights"},"IBC client heights"),(0,a.yg)("p",null,"IBC Client Heights are represented by the struct:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"type Height struct {\n  RevisionNumber uint64\n  RevisionHeight uint64\n}\n")),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"RevisionNumber")," represents the revision of the chain that the height is representing.\nA revision typically represents a continuous, monotonically increasing range of block-heights.\nThe ",(0,a.yg)("inlineCode",{parentName:"p"},"RevisionHeight")," represents the height of the chain within the given revision."),(0,a.yg)("p",null,"On any reset of the ",(0,a.yg)("inlineCode",{parentName:"p"},"RevisionHeight"),"\u2014for example, when hard-forking a Tendermint chain,\nthe ",(0,a.yg)("inlineCode",{parentName:"p"},"RevisionNumber")," will get incremented. This allows IBC clients to distinguish between a\nblock height ",(0,a.yg)("inlineCode",{parentName:"p"},"n")," of a previous revision of the chain (at revision ",(0,a.yg)("inlineCode",{parentName:"p"},"p"),") and block-height ",(0,a.yg)("inlineCode",{parentName:"p"},"n")," of the current\nrevision of the chain (at revision ",(0,a.yg)("inlineCode",{parentName:"p"},"e"),")."),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"Height"),"s that share the same revision number can be compared by simply comparing their respective ",(0,a.yg)("inlineCode",{parentName:"p"},"RevisionHeight"),"s.\n",(0,a.yg)("inlineCode",{parentName:"p"},"Height"),"s that do not share the same revision number will only be compared using their respective ",(0,a.yg)("inlineCode",{parentName:"p"},"RevisionNumber"),"s.\nThus a height ",(0,a.yg)("inlineCode",{parentName:"p"},"h")," with revision number ",(0,a.yg)("inlineCode",{parentName:"p"},"e+1")," will always be greater than a height ",(0,a.yg)("inlineCode",{parentName:"p"},"g")," with revision number ",(0,a.yg)("inlineCode",{parentName:"p"},"e"),",\n",(0,a.yg)("strong",{parentName:"p"},"REGARDLESS")," of the difference in revision heights."),(0,a.yg)("p",null,"For example:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"Height{RevisionNumber: 3, RevisionHeight: 0} > Height{RevisionNumber: 2, RevisionHeight: 100000000000}\n")),(0,a.yg)("p",null,"When a Tendermint chain is running a particular revision, relayers can simply submit headers and proofs with the revision number\ngiven by the chain's ",(0,a.yg)("inlineCode",{parentName:"p"},"chainID"),", and the revision height given by the Tendermint block height. When a chain updates using a hard-fork\nand resets its block-height, it is responsible for updating its ",(0,a.yg)("inlineCode",{parentName:"p"},"chainID")," to increment the revision number.\nIBC Tendermint clients then verifies the revision number against their ",(0,a.yg)("inlineCode",{parentName:"p"},"chainID")," and treat the ",(0,a.yg)("inlineCode",{parentName:"p"},"RevisionHeight")," as the Tendermint block-height."),(0,a.yg)("p",null,"Tendermint chains wishing to use revisions to maintain persistent IBC connections even across height-resetting upgrades must format their ",(0,a.yg)("inlineCode",{parentName:"p"},"chainID"),"s\nin the following manner: ",(0,a.yg)("inlineCode",{parentName:"p"},"{chainID}-{revision_number}"),". On any height-resetting upgrade, the ",(0,a.yg)("inlineCode",{parentName:"p"},"chainID")," ",(0,a.yg)("strong",{parentName:"p"},"MUST")," be updated with a higher revision number\nthan the previous value."),(0,a.yg)("p",null,"For example:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Before upgrade ",(0,a.yg)("inlineCode",{parentName:"li"},"chainID"),": ",(0,a.yg)("inlineCode",{parentName:"li"},"gaiamainnet-3")),(0,a.yg)("li",{parentName:"ul"},"After upgrade ",(0,a.yg)("inlineCode",{parentName:"li"},"chainID"),": ",(0,a.yg)("inlineCode",{parentName:"li"},"gaiamainnet-4"))),(0,a.yg)("p",null,"Clients that do not require revisions, such as the ",(0,a.yg)("inlineCode",{parentName:"p"},"06-solomachine")," client, can simply hardcode ",(0,a.yg)("inlineCode",{parentName:"p"},"0")," into the revision number whenever they\nneed to return an IBC height when implementing IBC interfaces and use the ",(0,a.yg)("inlineCode",{parentName:"p"},"RevisionHeight")," exclusively."),(0,a.yg)("p",null,"Other client types can implement their own logic to verify the IBC heights that relayers provide in their ",(0,a.yg)("inlineCode",{parentName:"p"},"Update"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"Misbehavior"),", and\n",(0,a.yg)("inlineCode",{parentName:"p"},"Verify")," functions respectively."),(0,a.yg)("p",null,"The IBC interfaces expect an ",(0,a.yg)("inlineCode",{parentName:"p"},"ibcexported.Height")," interface, however all clients must use the concrete implementation provided in\n",(0,a.yg)("inlineCode",{parentName:"p"},"02-client/types")," and reproduced above."),(0,a.yg)("h3",{id:"connections"},(0,a.yg)("a",{parentName:"h3",href:"https://github.com/cosmos/ibc-go/blob/main/modules/core/03-connection"},"Connections")),(0,a.yg)("p",null,"Connections encapsulate two ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/cosmos/ibc-go/blob/v8.0.0/proto/ibc/core/connection/v1/connection.proto#L17"},(0,a.yg)("inlineCode",{parentName:"a"},"ConnectionEnd")),"\nobjects on two separate blockchains. Each ",(0,a.yg)("inlineCode",{parentName:"p"},"ConnectionEnd")," is associated with a client of the\nother blockchain (for example, the counterparty blockchain). The connection handshake is responsible\nfor verifying that the light clients on each chain are correct for their respective counterparties.\nConnections, once established, are responsible for facilitating all cross-chain verifications of IBC state.\nA connection can be associated with any number of channels."),(0,a.yg)("p",null,"The connection handshake is a 4-step handshake. Briefly, if a given chain A wants to open a connection with\nchain B using already established light clients on both chains:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"chain A sends a ",(0,a.yg)("inlineCode",{parentName:"li"},"ConnectionOpenInit")," message to signal a connection initialization attempt with chain B."),(0,a.yg)("li",{parentName:"ol"},"chain B sends a ",(0,a.yg)("inlineCode",{parentName:"li"},"ConnectionOpenTry")," message to try opening the connection on chain A."),(0,a.yg)("li",{parentName:"ol"},"chain A sends a ",(0,a.yg)("inlineCode",{parentName:"li"},"ConnectionOpenAck")," message to mark its connection end state as open."),(0,a.yg)("li",{parentName:"ol"},"chain B sends a ",(0,a.yg)("inlineCode",{parentName:"li"},"ConnectionOpenConfirm")," message to mark its connection end state as open.")),(0,a.yg)("h4",{id:"time-delayed-connections"},"Time delayed connections"),(0,a.yg)("p",null,"Connections can be opened with a time delay by setting the ",(0,a.yg)("inlineCode",{parentName:"p"},"delay_period")," field (in nanoseconds) in the ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/cosmos/ibc-go/blob/v8.0.0/proto/ibc/core/connection/v1/tx.proto#L45"},(0,a.yg)("inlineCode",{parentName:"a"},"MsgConnectionOpenInit")),".\nThe time delay is used to require that the underlying light clients have been updated to a certain height before commitment verification can be performed."),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"delayPeriod")," is used in conjunction with the ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/cosmos/ibc-go/blob/v8.0.0/proto/ibc/core/connection/v1/connection.proto#L113"},(0,a.yg)("inlineCode",{parentName:"a"},"max_expected_time_per_block"))," parameter of the connection submodule to determine the ",(0,a.yg)("inlineCode",{parentName:"p"},"blockDelay"),", which is number of blocks that the connection must be delayed by."),(0,a.yg)("p",null,"When commitment verification is performed, the connection submodule will pass ",(0,a.yg)("inlineCode",{parentName:"p"},"delayPeriod")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"blockDelay")," to the light client. It is up to the light client to determine whether the light client has been updated to the required height. Only the following light clients in ",(0,a.yg)("inlineCode",{parentName:"p"},"ibc-go")," support time delayed connections:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"07-tendermint")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"08-wasm")," (passed to the contact)")),(0,a.yg)("h3",{id:"proofs-and-paths"},(0,a.yg)("a",{parentName:"h3",href:"https://github.com/cosmos/ibc-go/blob/main/modules/core/23-commitment"},"Proofs")," and ",(0,a.yg)("a",{parentName:"h3",href:"https://github.com/cosmos/ibc-go/blob/main/modules/core/24-host"},"paths")),(0,a.yg)("p",null,"In IBC, blockchains do not directly pass messages to each other over the network. Instead, to\ncommunicate, a blockchain commits some state to a specifically defined path that is reserved for a\nspecific message type and a specific counterparty. For example, for storing a specific connectionEnd as part\nof a handshake or a packet intended to be relayed to a module on the counterparty chain. A relayer\nprocess monitors for updates to these paths and relays messages by submitting the data stored\nunder the path and a proof to the counterparty chain."),(0,a.yg)("p",null,"Proofs are passed from core IBC to light clients as bytes. It is up to light client implementations to interpret these bytes appropriately."),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"The paths that all IBC implementations must use for committing IBC messages is defined in\n",(0,a.yg)("a",{parentName:"li",href:"https://github.com/cosmos/ibc/tree/master/spec/core/ics-024-host-requirements"},"ICS-24 Host State Machine Requirements"),"."),(0,a.yg)("li",{parentName:"ul"},"The proof format that all implementations must be able to produce and verify is defined in ",(0,a.yg)("a",{parentName:"li",href:"https://github.com/cosmos/ics23"},"ICS-23 Proofs")," implementation.")),(0,a.yg)("h3",{id:"ports"},(0,a.yg)("a",{parentName:"h3",href:"https://github.com/cosmos/ibc-go/blob/main/modules/core/05-port"},"Ports")),(0,a.yg)("p",null,"An IBC module can bind to any number of ports. Each port must be identified by a unique ",(0,a.yg)("inlineCode",{parentName:"p"},"portID"),".\nSince IBC is designed to be secure with mutually distrusted modules operating on the same ledger,\nbinding a port returns a dynamic object capability. In order to take action on a particular port\n(for example, an open channel with its port ID), a module must provide the dynamic object capability to the IBC\nhandler. This requirement prevents a malicious module from opening channels with ports it does not own. Thus,\nIBC modules are responsible for claiming the capability that is returned on ",(0,a.yg)("inlineCode",{parentName:"p"},"BindPort"),"."),(0,a.yg)("h3",{id:"channels"},(0,a.yg)("a",{parentName:"h3",href:"https://github.com/cosmos/ibc-go/blob/main/modules/core/04-channel"},"Channels")),(0,a.yg)("p",null,"An IBC channel can be established between two IBC ports. Currently, a port is exclusively owned by a\nsingle module. IBC packets are sent over channels. Just as IP packets contain the destination IP\naddress and IP port, and the source IP address and source IP port, IBC packets contain\nthe destination port ID and channel ID, and the source port ID and channel ID. This packet structure enables IBC to\ncorrectly route packets to the destination module while allowing modules receiving packets to\nknow the sender module."),(0,a.yg)("p",null,"A channel can be ",(0,a.yg)("inlineCode",{parentName:"p"},"ORDERED"),", where packets from a sending module must be processed by the\nreceiving module in the order they were sent. Or a channel can be ",(0,a.yg)("inlineCode",{parentName:"p"},"UNORDERED"),", where packets\nfrom a sending module are processed in the order they arrive (might be in a different order than they were sent)."),(0,a.yg)("p",null,"Modules can choose which channels they wish to communicate over with, thus IBC expects modules to\nimplement callbacks that are called during the channel handshake. These callbacks can do custom\nchannel initialization logic. If any callback returns an error, the channel handshake fails. Thus, by\nreturning errors on callbacks, modules can programmatically reject and accept channels."),(0,a.yg)("p",null,"The channel handshake is a 4-step handshake. Briefly, if a given chain A wants to open a channel with\nchain B using an already established connection:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"chain A sends a ",(0,a.yg)("inlineCode",{parentName:"li"},"ChanOpenInit")," message to signal a channel initialization attempt with chain B."),(0,a.yg)("li",{parentName:"ol"},"chain B sends a ",(0,a.yg)("inlineCode",{parentName:"li"},"ChanOpenTry")," message to try opening the channel on chain A."),(0,a.yg)("li",{parentName:"ol"},"chain A sends a ",(0,a.yg)("inlineCode",{parentName:"li"},"ChanOpenAck")," message to mark its channel end status as open."),(0,a.yg)("li",{parentName:"ol"},"chain B sends a ",(0,a.yg)("inlineCode",{parentName:"li"},"ChanOpenConfirm")," message to mark its channel end status as open.")),(0,a.yg)("p",null,"If all handshake steps are successful, the channel is opened on both sides. At each step in the handshake, the module\nassociated with the ",(0,a.yg)("inlineCode",{parentName:"p"},"ChannelEnd")," executes its callback. So\non ",(0,a.yg)("inlineCode",{parentName:"p"},"ChanOpenInit"),", the module on chain A executes its callback ",(0,a.yg)("inlineCode",{parentName:"p"},"OnChanOpenInit"),"."),(0,a.yg)("p",null,"The channel identifier is auto derived in the format: ",(0,a.yg)("inlineCode",{parentName:"p"},"channel-{N}")," where ",(0,a.yg)("inlineCode",{parentName:"p"},"N")," is the next sequence to be used."),(0,a.yg)("h4",{id:"closing-channels"},"Closing channels"),(0,a.yg)("p",null,"Closing a channel occurs in 2 handshake steps as defined in ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/cosmos/ibc/tree/master/spec/core/ics-004-channel-and-packet-semantics"},"ICS 04"),".\nOnce a channel is closed, it cannot be reopened. The channel handshake steps are:"),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},(0,a.yg)("inlineCode",{parentName:"strong"},"ChanCloseInit"))," closes a channel on the executing chain if"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"the channel exists and it is not already closed,"),(0,a.yg)("li",{parentName:"ul"},"the connection it exists upon is ",(0,a.yg)("inlineCode",{parentName:"li"},"OPEN"),","),(0,a.yg)("li",{parentName:"ul"},"the ",(0,a.yg)("a",{parentName:"li",href:"/dev-portal-docsite/ibc-go/next/ibc/apps/ibcmodule#channel-closing-callbacks"},"IBC module callback ",(0,a.yg)("inlineCode",{parentName:"a"},"OnChanCloseInit"))," returns ",(0,a.yg)("inlineCode",{parentName:"li"},"nil"),".")),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"ChanCloseInit")," can be initiated by any user by submitting a ",(0,a.yg)("inlineCode",{parentName:"p"},"MsgChannelCloseInit")," transaction.\nNote that channels are automatically closed when a packet times out on an ",(0,a.yg)("inlineCode",{parentName:"p"},"ORDERED")," channel.\nA timeout on an ",(0,a.yg)("inlineCode",{parentName:"p"},"ORDERED")," channel skips the ",(0,a.yg)("inlineCode",{parentName:"p"},"ChanCloseInit")," step and immediately closes the channel."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},(0,a.yg)("inlineCode",{parentName:"strong"},"ChanCloseConfirm"))," is a response to a counterparty channel executing ",(0,a.yg)("inlineCode",{parentName:"p"},"ChanCloseInit"),". The channel\non the executing chain closes if"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"the channel exists and is not already closed,"),(0,a.yg)("li",{parentName:"ul"},"the connection the channel exists upon is ",(0,a.yg)("inlineCode",{parentName:"li"},"OPEN"),","),(0,a.yg)("li",{parentName:"ul"},"the executing chain successfully verifies that the counterparty channel has been closed"),(0,a.yg)("li",{parentName:"ul"},"the ",(0,a.yg)("a",{parentName:"li",href:"/dev-portal-docsite/ibc-go/next/ibc/apps/ibcmodule#channel-closing-callbacks"},"IBC module callback ",(0,a.yg)("inlineCode",{parentName:"a"},"OnChanCloseConfirm"))," returns ",(0,a.yg)("inlineCode",{parentName:"li"},"nil"),".")),(0,a.yg)("p",null,"Currently, none of the IBC applications provided in ibc-go support ",(0,a.yg)("inlineCode",{parentName:"p"},"ChanCloseInit"),"."),(0,a.yg)("h3",{id:"packets"},(0,a.yg)("a",{parentName:"h3",href:"https://github.com/cosmos/ibc-go/blob/main/modules/core/04-channel"},"Packets")),(0,a.yg)("p",null,"Modules communicate with each other by sending packets over IBC channels. All\nIBC packets contain the destination ",(0,a.yg)("inlineCode",{parentName:"p"},"portID")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"channelID")," along with the source ",(0,a.yg)("inlineCode",{parentName:"p"},"portID")," and\n",(0,a.yg)("inlineCode",{parentName:"p"},"channelID"),". This packet structure allows modules to know the sender module of a given packet. IBC packets\ncontain a sequence to optionally enforce ordering."),(0,a.yg)("p",null,"IBC packets also contain a ",(0,a.yg)("inlineCode",{parentName:"p"},"TimeoutHeight")," and a ",(0,a.yg)("inlineCode",{parentName:"p"},"TimeoutTimestamp")," that determine the deadline before the receiving module must process a packet."),(0,a.yg)("p",null,"Modules send custom application data to each other inside the ",(0,a.yg)("inlineCode",{parentName:"p"},"Data")," ",(0,a.yg)("inlineCode",{parentName:"p"},"[]byte")," field of the IBC packet.\nThus, packet data is opaque to IBC handlers. It is incumbent on a sender module to encode\ntheir application-specific packet information into the ",(0,a.yg)("inlineCode",{parentName:"p"},"Data")," field of packets. The receiver\nmodule must decode that ",(0,a.yg)("inlineCode",{parentName:"p"},"Data")," back to the original application data."),(0,a.yg)("h3",{id:"receipts-and-timeouts"},(0,a.yg)("a",{parentName:"h3",href:"https://github.com/cosmos/ibc-go/blob/main/modules/core/04-channel"},"Receipts and timeouts")),(0,a.yg)("p",null,"Since IBC works over a distributed network and relies on potentially faulty relayers to relay messages between ledgers,\nIBC must handle the case where a packet does not get sent to its destination in a timely manner or at all. Packets must\nspecify a non-zero value for timeout height (",(0,a.yg)("inlineCode",{parentName:"p"},"TimeoutHeight"),") or timeout timestamp (",(0,a.yg)("inlineCode",{parentName:"p"},"TimeoutTimestamp")," ) after which a packet can no longer be successfully received on the destination chain."),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"The ",(0,a.yg)("inlineCode",{parentName:"li"},"timeoutHeight")," indicates a consensus height on the destination chain after which the packet is no longer to be processed, and instead counts as having timed-out."),(0,a.yg)("li",{parentName:"ul"},"The ",(0,a.yg)("inlineCode",{parentName:"li"},"timeoutTimestamp")," indicates a timestamp on the destination chain after which the packet is no longer to be processed, and instead counts as having timed-out.")),(0,a.yg)("p",null,"If the timeout passes without the packet being successfully received, the packet can no longer be\nreceived on the destination chain. The sending module can timeout the packet and take appropriate actions."),(0,a.yg)("p",null,"If the timeout is reached, then a proof of packet timeout can be submitted to the original chain. The original chain can then perform\napplication-specific logic to timeout the packet, perhaps by rolling back the packet send changes (refunding senders any locked funds, etc)."),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"In ",(0,a.yg)("inlineCode",{parentName:"p"},"ORDERED")," channels, a timeout of a single packet in the channel causes the channel to close."),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"If packet sequence ",(0,a.yg)("inlineCode",{parentName:"li"},"n")," times out, then a packet at sequence ",(0,a.yg)("inlineCode",{parentName:"li"},"k > n")," cannot be received without violating the contract of ",(0,a.yg)("inlineCode",{parentName:"li"},"ORDERED")," channels that packets are processed in the order that they are sent."),(0,a.yg)("li",{parentName:"ul"},"Since ",(0,a.yg)("inlineCode",{parentName:"li"},"ORDERED")," channels enforce this invariant, a proof that sequence ",(0,a.yg)("inlineCode",{parentName:"li"},"n")," has not been received on the destination chain by the specified timeout of packet ",(0,a.yg)("inlineCode",{parentName:"li"},"n")," is sufficient to timeout packet ",(0,a.yg)("inlineCode",{parentName:"li"},"n")," and close the channel."))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"In ",(0,a.yg)("inlineCode",{parentName:"p"},"UNORDERED")," channels, the application-specific timeout logic for that packet is applied and the channel is not closed."),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Packets can be received in any order."),(0,a.yg)("li",{parentName:"ul"},"IBC writes a packet receipt for each sequence received in the ",(0,a.yg)("inlineCode",{parentName:"li"},"UNORDERED")," channel. This receipt does not contain information; it is simply a marker intended to signify that the ",(0,a.yg)("inlineCode",{parentName:"li"},"UNORDERED")," channel has received a packet at the specified sequence."),(0,a.yg)("li",{parentName:"ul"},"To timeout a packet on an ",(0,a.yg)("inlineCode",{parentName:"li"},"UNORDERED")," channel, a proof is required that a packet receipt ",(0,a.yg)("strong",{parentName:"li"},"does not exist")," for the packet's sequence by the specified timeout.  ")))),(0,a.yg)("p",null,"For this reason, most modules should use ",(0,a.yg)("inlineCode",{parentName:"p"},"UNORDERED")," channels as they require fewer liveness guarantees to function effectively for users of that channel."),(0,a.yg)("h3",{id:"acknowledgments"},(0,a.yg)("a",{parentName:"h3",href:"https://github.com/cosmos/ibc-go/blob/main/modules/core/04-channel"},"Acknowledgments")),(0,a.yg)("p",null,"Modules can also choose to write application-specific acknowledgments upon processing a packet. Acknowledgments can be done:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Synchronously on ",(0,a.yg)("inlineCode",{parentName:"li"},"OnRecvPacket")," if the module processes packets as soon as they are received from IBC module."),(0,a.yg)("li",{parentName:"ul"},"Asynchronously if module processes packets at some later point after receiving the packet.")),(0,a.yg)("p",null,"This acknowledgment data is opaque to IBC much like the packet ",(0,a.yg)("inlineCode",{parentName:"p"},"Data")," and is treated by IBC as a simple byte string ",(0,a.yg)("inlineCode",{parentName:"p"},"[]byte"),". Receiver modules must encode their acknowledgment so that the sender module can decode it correctly. The encoding must be negotiated between the two parties during version negotiation in the channel handshake."),(0,a.yg)("p",null,"The acknowledgment can encode whether the packet processing succeeded or failed, along with additional information that allows the sender module to take appropriate action."),(0,a.yg)("p",null,"After the acknowledgment has been written by the receiving chain, a relayer relays the acknowledgment back to the original sender module."),(0,a.yg)("p",null,"The original sender module then executes application-specific acknowledgment logic using the contents of the acknowledgment."),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"After an acknowledgement fails, packet-send changes can be rolled back (for example, refunding senders in ICS 20)."),(0,a.yg)("li",{parentName:"ul"},"After an acknowledgment is received successfully on the original sender on the chain, the corresponding packet commitment is deleted since it is no longer needed.")),(0,a.yg)("h2",{id:"further-readings-and-specs"},"Further readings and specs"),(0,a.yg)("p",null,"If you want to learn more about IBC, check the following specifications:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"https://github.com/cosmos/ibc/blob/master/README.md"},"IBC specification overview"))))}d.isMDXComponent=!0}}]);