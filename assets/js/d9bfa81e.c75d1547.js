"use strict";(self.webpackChunkdev_portal_docsite=self.webpackChunkdev_portal_docsite||[]).push([[44607],{15680:(e,t,a)=>{a.d(t,{xA:()=>d,yg:()=>h});var o=a(96540);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,o)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,o,n=function(e,t){if(null==e)return{};var a,o,n={},s=Object.keys(e);for(o=0;o<s.length;o++)a=s[o],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)a=s[o],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=o.createContext({}),p=function(e){var t=o.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},d=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var a=e.components,n=e.mdxType,s=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),m=p(a),u=n,h=m["".concat(l,".").concat(u)]||m[u]||c[u]||s;return a?o.createElement(h,r(r({ref:t},d),{},{components:a})):o.createElement(h,r({ref:t},d))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var s=a.length,r=new Array(s);r[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[m]="string"==typeof e?e:n,r[1]=i;for(var p=2;p<s;p++)r[p]=a[p];return o.createElement.apply(null,r)}return o.createElement.apply(null,a)}u.displayName="MDXCreateElement"},70274:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>s,metadata:()=>i,toc:()=>p});var o=a(58168),n=(a(96540),a(15680));const s={sidebar_position:1},r="Main Components of the Cosmos SDK",i={unversionedId:"learn/intro/sdk-design",id:"version-0.52/learn/intro/sdk-design",title:"Main Components of the Cosmos SDK",description:"The Cosmos SDK is a framework that facilitates the development of secure state-machines on top of CometBFT. At its core, the Cosmos SDK is a boilerplate implementation of the ABCI in Golang. It comes with a multistore to persist data and a router to handle transactions.",source:"@site/cosmos-sdk_versioned_docs/version-0.52/learn/intro/03-sdk-design.md",sourceDirName:"learn/intro",slug:"/learn/intro/sdk-design",permalink:"/dev-portal-docsite/cosmos-sdk/learn/intro/sdk-design",draft:!1,tags:[],version:"0.52",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"learnSidebar",previous:{title:"Blockchain Architecture",permalink:"/dev-portal-docsite/cosmos-sdk/learn/intro/sdk-app-architecture"},next:{title:"Anatomy of a Cosmos SDK Application",permalink:"/dev-portal-docsite/cosmos-sdk/learn/beginner/app-anatomy"}},l={},p=[{value:"<code>baseapp</code>",id:"baseapp",level:2},{value:"Multistore",id:"multistore",level:2},{value:"Modules",id:"modules",level:2}],d={toc:p},m="wrapper";function c(e){let{components:t,...s}=e;return(0,n.yg)(m,(0,o.A)({},d,s,{components:t,mdxType:"MDXLayout"}),(0,n.yg)("h1",{id:"main-components-of-the-cosmos-sdk"},"Main Components of the Cosmos SDK"),(0,n.yg)("p",null,"The Cosmos SDK is a framework that facilitates the development of secure state-machines on top of CometBFT. At its core, the Cosmos SDK is a boilerplate implementation of the ",(0,n.yg)("a",{parentName:"p",href:"/dev-portal-docsite/cosmos-sdk/learn/intro/sdk-app-architecture#abci"},"ABCI")," in Golang. It comes with a ",(0,n.yg)("a",{parentName:"p",href:"/dev-portal-docsite/cosmos-sdk/learn/advanced/store#multistore"},(0,n.yg)("inlineCode",{parentName:"a"},"multistore"))," to persist data and a ",(0,n.yg)("a",{parentName:"p",href:"/dev-portal-docsite/cosmos-sdk/learn/advanced/baseapp#service-routers"},(0,n.yg)("inlineCode",{parentName:"a"},"router"))," to handle transactions."),(0,n.yg)("p",null,"Here is a simplified view of how transactions are handled by an application built on top of the Cosmos SDK when transferred from CometBFT via ",(0,n.yg)("inlineCode",{parentName:"p"},"DeliverTx"),":"),(0,n.yg)("ol",null,(0,n.yg)("li",{parentName:"ol"},"Decode ",(0,n.yg)("inlineCode",{parentName:"li"},"transactions")," received from the CometBFT consensus engine (remember that CometBFT only deals with ",(0,n.yg)("inlineCode",{parentName:"li"},"[]bytes"),")."),(0,n.yg)("li",{parentName:"ol"},"Extract ",(0,n.yg)("inlineCode",{parentName:"li"},"messages")," from ",(0,n.yg)("inlineCode",{parentName:"li"},"transactions")," and do basic sanity checks."),(0,n.yg)("li",{parentName:"ol"},"Route each message to the appropriate module so that it can be processed."),(0,n.yg)("li",{parentName:"ol"},"Commit state changes.")),(0,n.yg)("p",null,(0,n.yg)("img",{alt:"main-components",src:a(9768).A,width:"637",height:"349"})),(0,n.yg)("h2",{id:"baseapp"},(0,n.yg)("inlineCode",{parentName:"h2"},"baseapp")),(0,n.yg)("p",null,(0,n.yg)("inlineCode",{parentName:"p"},"baseapp")," is the boilerplate implementation of a Cosmos SDK application. It comes with an implementation of the ABCI to handle the connection with the underlying consensus engine. Typically, a Cosmos SDK application extends ",(0,n.yg)("inlineCode",{parentName:"p"},"baseapp")," by embedding it in ",(0,n.yg)("a",{parentName:"p",href:"/dev-portal-docsite/cosmos-sdk/learn/beginner/app-anatomy#core-application-file"},(0,n.yg)("inlineCode",{parentName:"a"},"app.go")),"."),(0,n.yg)("p",null,"Here is an example of this from ",(0,n.yg)("inlineCode",{parentName:"p"},"simapp"),", the Cosmos SDK demonstration app:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-go",metastring:"reference",reference:!0},"https://github.com/cosmos/cosmos-sdk/blob/v0.52.0-beta.1/simapp/app.go#L145-L186\n")),(0,n.yg)("p",null,"The goal of ",(0,n.yg)("inlineCode",{parentName:"p"},"baseapp")," is to provide a secure interface between the store and the extensible state machine while defining as little about the state machine as possible (staying true to the ABCI)."),(0,n.yg)("p",null,"For more on ",(0,n.yg)("inlineCode",{parentName:"p"},"baseapp"),", please click ",(0,n.yg)("a",{parentName:"p",href:"/dev-portal-docsite/cosmos-sdk/learn/advanced/baseapp"},"here"),"."),(0,n.yg)("h2",{id:"multistore"},"Multistore"),(0,n.yg)("p",null,"The Cosmos SDK provides a ",(0,n.yg)("a",{parentName:"p",href:"/dev-portal-docsite/cosmos-sdk/learn/advanced/store#multistore"},(0,n.yg)("inlineCode",{parentName:"a"},"multistore"))," for persisting state. The multistore allows developers to declare any number of ",(0,n.yg)("a",{parentName:"p",href:"/dev-portal-docsite/cosmos-sdk/learn/advanced/store#base-layer-kvstores"},(0,n.yg)("inlineCode",{parentName:"a"},"KVStores")),". These ",(0,n.yg)("inlineCode",{parentName:"p"},"KVStores")," only accept the ",(0,n.yg)("inlineCode",{parentName:"p"},"[]byte")," type as value and therefore any custom structure needs to be marshalled using ",(0,n.yg)("a",{parentName:"p",href:"/dev-portal-docsite/cosmos-sdk/learn/advanced/encoding"},"a codec")," before being stored."),(0,n.yg)("p",null,"The multistore abstraction is used to divide the state in distinct compartments, each managed by its own module. For more on the multistore, click ",(0,n.yg)("a",{parentName:"p",href:"/dev-portal-docsite/cosmos-sdk/learn/advanced/store#multistore"},"here"),"."),(0,n.yg)("h2",{id:"modules"},"Modules"),(0,n.yg)("p",null,"The power of the Cosmos SDK lies in its modularity. Cosmos SDK applications are built by aggregating a collection of interoperable modules. Each module defines a subset of the state and contains its own message/transaction processor, while the Cosmos SDK is responsible for routing each message to its respective module."),(0,n.yg)("p",null,"Here is a simplified view of how a transaction is processed by the application of each full-node when it is received in a valid block:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-mermaid"},' flowchart TD\n    A[Transaction relayed from the full-node\'s CometBFT engine to the node\'s application via DeliverTx] --\x3e B[APPLICATION]\n    B --\x3e|"Using baseapp\'s methods: Decode the Tx, extract and route the message(s)"| C[Message routed to the correct module to be processed]\n    C --\x3e D1[AUTH MODULE]\n    C --\x3e D2[BANK MODULE]\n    C --\x3e D3[STAKING MODULE]\n    C --\x3e D4[GOV MODULE]\n    D1 --\x3e|Handle message, Update state| E["Return result to CometBFT (0=Ok, 1=Err)"]\n    D2 --\x3e|Handle message, Update state| E["Return result to CometBFT (0=Ok, 1=Err)"]\n    D3 --\x3e|Handle message, Update state| E["Return result to CometBFT (0=Ok, 1=Err)"]\n    D4 --\x3e|Handle message, Update state| E["Return result to CometBFT (0=Ok, 1=Err)"]\n')),(0,n.yg)("p",null,"Each module can be seen as a little state-machine. Developers need to define the subset of the state handled by the module, as well as custom message types that modify the state (",(0,n.yg)("em",{parentName:"p"},"Note:")," ",(0,n.yg)("inlineCode",{parentName:"p"},"messages")," are extracted from ",(0,n.yg)("inlineCode",{parentName:"p"},"transactions")," by ",(0,n.yg)("inlineCode",{parentName:"p"},"baseapp"),"). In general, each module declares its own ",(0,n.yg)("inlineCode",{parentName:"p"},"KVStore")," in the ",(0,n.yg)("inlineCode",{parentName:"p"},"multistore")," to persist the subset of the state it defines. Most developers will need to access other 3rd party modules when building their own modules. Given that the Cosmos SDK is an open framework, some of the modules may be malicious, which means there is a need for security principles to reason about inter-module interactions. These principles are based on ",(0,n.yg)("a",{parentName:"p",href:"/dev-portal-docsite/cosmos-sdk/learn/advanced/ocap"},"object-capabilities"),". In practice, this means that instead of having each module keep an access control list for other modules, each module implements special objects called ",(0,n.yg)("inlineCode",{parentName:"p"},"keepers")," that can be passed to other modules to grant a pre-defined set of capabilities."),(0,n.yg)("p",null,"Cosmos SDK modules are defined in the ",(0,n.yg)("inlineCode",{parentName:"p"},"x/")," folder of the Cosmos SDK. Some core modules include:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("inlineCode",{parentName:"li"},"x/auth"),": Used to manage accounts and signatures."),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("inlineCode",{parentName:"li"},"x/bank"),": Used to enable tokens and token transfers."),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("inlineCode",{parentName:"li"},"x/staking")," + ",(0,n.yg)("inlineCode",{parentName:"li"},"x/slashing"),": Used to build Proof-of-Stake blockchains.")),(0,n.yg)("p",null,"In addition to the already existing modules in ",(0,n.yg)("inlineCode",{parentName:"p"},"x/"),", which anyone can use in their app, the Cosmos SDK lets you build your own custom modules. You can check an ",(0,n.yg)("a",{parentName:"p",href:"https://tutorials.cosmos.network/"},"example of that in the tutorial"),"."))}c.isMDXComponent=!0},9768:(e,t,a)=>{a.d(t,{A:()=>o});const o=a.p+"assets/images/main-components-a5ee95b25211e082497a59defe834d24.png"}}]);