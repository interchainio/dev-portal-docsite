"use strict";(self.webpackChunkdev_portal_docsite=self.webpackChunkdev_portal_docsite||[]).push([[50422],{15680:(e,n,t)=>{t.d(n,{xA:()=>u,yg:()=>h});var a=t(96540);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,s=e.originalType,l=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),d=c(t),m=o,h=d["".concat(l,".").concat(m)]||d[m]||p[m]||s;return t?a.createElement(h,i(i({ref:n},u),{},{components:t})):a.createElement(h,i({ref:n},u))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var s=t.length,i=new Array(s);i[0]=m;var r={};for(var l in n)hasOwnProperty.call(n,l)&&(r[l]=n[l]);r.originalType=e,r[d]="string"==typeof e?e:o,i[1]=r;for(var c=2;c<s;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},5391:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var a=t(58168),o=(t(96540),t(15680));const s={},i="ADR 75: V2 Upgrades",r={unversionedId:"docs/architecture/adr-75-v2",id:"docs/architecture/adr-75-v2",title:"ADR 75: V2 Upgrades",description:"Changelog",source:"@site/cosmos-sdk/docs/architecture/adr-75-v2.md",sourceDirName:"docs/architecture",slug:"/docs/architecture/adr-75-v2",permalink:"/dev-portal-docsite/cosmos-sdk/next/docs/architecture/adr-75-v2",draft:!1,tags:[],version:"current",frontMatter:{}},l={},c=[{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Abstract",id:"abstract",level:2},{value:"Context",id:"context",level:2},{value:"Alternatives",id:"alternatives",level:2},{value:"Decision",id:"decision",level:2},{value:"Consensus",id:"consensus",level:3},{value:"State Transition Function",id:"state-transition-function",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Backwards Compatibility",id:"backwards-compatibility",level:3},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Further Discussions",id:"further-discussions",level:2},{value:"References",id:"references",level:2}],u={toc:c},d="wrapper";function p(e){let{components:n,...t}=e;return(0,o.yg)(d,(0,a.A)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"adr-75-v2-upgrades"},"ADR 75: V2 Upgrades"),(0,o.yg)("h2",{id:"changelog"},"Changelog"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"2023-11-07: Initial Draft")),(0,o.yg)("h2",{id:"status"},"Status"),(0,o.yg)("p",null,"DRAFT"),(0,o.yg)("h2",{id:"abstract"},"Abstract"),(0,o.yg)("p",null,"V2 is a reset in the Cosmos SDK architecture. It is a complete rewrite of the SDK, with a focus on modularity, extensibility, and performance. The V2 SDK breaks apart the core SDK into smaller modular components allowing users to pick and choose the components they need for their specific use case. This document outlines the changes and migration path for users of the V1 SDK."),(0,o.yg)("h2",{id:"context"},"Context"),(0,o.yg)("p",null,"The Cosmos SDK began in 2016, at this time the software was written with the direct use case of the Cosmos Hub.Since then we have seen the SDK evolve and grow, with new features and improvements being added over time. The SDK today is used by over 100 different projects, with more users joining the ecosystem every day. This has led to a number of challenges, including:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"The SDK is becoming increasingly complex, with many different components and dependencies."),(0,o.yg)("li",{parentName:"ul"},"The SDK is becoming more difficult to maintain, with frequent breaking changes and compatibility issues.")),(0,o.yg)("p",null,"V2 is a complete rewrite of the Cosmos SDK, with a focus on modularity, extensibility, and performance. The goal is to make the Cosmos SDK easier to use for the various use cases that we have seen emerging in the ecosystem. "),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-mermaid"},"graph TD\n    Z[CometBFT] --\x3e A[Baseapp]\n    A[BaseApp] --\x3e B[ABCI Methods]\n    A --\x3e C[State Management]\n    A --\x3e D[Transaction Processing]\n    A --\x3e E[Query Handling]\n\n    B --\x3e B1[InitChain]\n    B --\x3e B2[Info]\n    B --\x3e B3[CheckTx]\n    B --\x3e B4[PrepareProposal]\n    B --\x3e B5[ProcessProposal]\n    B --\x3e B6[FinalizeBlock]\n    B --\x3e B7[Commit]\n\n    C --\x3e C1[Store]\n    C1 --\x3e C2[Iavl]\n\n    D --\x3e D1[runTx]\n    D1 --\x3e D2[Module]\n\n    E --\x3e E1[Query]\n    E1 --\x3e D2[Module]\n")),(0,o.yg)("p",null,"This is a high-level overview of Baseapp today. As we can see baseapp houses all the logic for the ABCI methods, state management, transaction processing, and query handling. This has led baseapp to be a very large monolith."),(0,o.yg)("h2",{id:"alternatives"},"Alternatives"),(0,o.yg)("p",null,"The alternative to doing a rewrite is to spend more time cleaning up baseapp. This would not fix issues around forking the repository to make changes like we see today. Keeping the current codebase does not allow the project to progress and reduce the maintenance burden on the project."),(0,o.yg)("h2",{id:"decision"},"Decision"),(0,o.yg)("p",null,"The Decision is to rewrite the core components (baseapp, server, store) of the SDK into smaller modules. "),(0,o.yg)("p",null,"These components will be broken into separate go.mods. The modules consist of the following:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Consensus"),(0,o.yg)("li",{parentName:"ul"},"STF  (State Transition Function)"),(0,o.yg)("li",{parentName:"ul"},"Server/v2"),(0,o.yg)("li",{parentName:"ul"},"Store/v2"),(0,o.yg)("li",{parentName:"ul"},"Runtime/v2")),(0,o.yg)("p",null,"The flow of all the components was designed to be as simple as possible, and the flow is as follows:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-mermaid"},'graph TD\n    subgraph Server\n        Mempool\n        E[Vote Extensions]\n        F[Prepare & Process Proposal]\n        Consensus\n        API[API]\n    end\nServer <--\x3e B["STF(State Transition Function)"]\nB <--\x3e C[Bank]\nB <--\x3e D[Auth]\nB <--\x3e G[Staking]\nServer --\x3e H[Storage]\nH --\x3e I[State Storage]\nH --\x3e J[State Commitment]\n')),(0,o.yg)("p",null,"In the above diagram we do not mention runtime/v2 because it is the componend that is responsible for combining all the other components into a single application."),(0,o.yg)("h3",{id:"consensus"},"Consensus"),(0,o.yg)("p",null,"Consensus is the component that handles communication to the Consensus Engine (Networking & Consensus). The default implementation will be CometBFT, but other consensus engines can be used with v2. The goal of consensus is not to offer a consensus API to meet all needs, but a way to allow developers to swap out the server for a different consensus engine. An application developer should not assume that the cometbftserver will work with other consensus engines. "),(0,o.yg)("p",null,"Consensus is the component that controls the interaction with the consensus engine, concurrency and execution models. For context, there are three execution models we have identified: "),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Immediate"),":",(0,o.yg)("ul",{parentName:"li"},(0,o.yg)("li",{parentName:"ul"},"Immediate execution differs from what Cosmos SDK utilizes today. In CometBFT, consensus at height N is executed at height N+1."),(0,o.yg)("li",{parentName:"ul"},"Immediate execution refers to coming to consensus at height N for the transactions in the same block."))),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Optimistic")," ",(0,o.yg)("ul",{parentName:"li"},(0,o.yg)("li",{parentName:"ul"},"Optimistic execution means different things to different applications. The way we imagine it working is that consensus may not be made on every block. Instead consensus is made after execution. This design favors a fast chain as it will not slow down for execution until the optimistic window  may be exceeded."))),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Delayed"),(0,o.yg)("ul",{parentName:"li"},(0,o.yg)("li",{parentName:"ul"},"Delayed execution is the default execution model in CometBFT. Consensus is made after execution, but the execution may be delayed until the next block.")))),(0,o.yg)("p",null,"The consensus server is responsible for handling the execution model of the state machine. The state machine executes transactions when it is told, it is unaware of the execution model."),(0,o.yg)("p",null,"Since consensus servers can be swapped there are certain features specific to consensus engines need to be implemented in the server. In the CometBFT server we have implemented the following features:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Mempool "),(0,o.yg)("li",{parentName:"ul"},"Prepare & Process Proposal"),(0,o.yg)("li",{parentName:"ul"},"Vote Extensions"),(0,o.yg)("li",{parentName:"ul"},"Snapshots")),(0,o.yg)("p",null,"If another consensus server would like to utilize the above features they can be copied or implemented in the server. "),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-mermaid"},"graph TD\n    subgraph Consensus\n        Mempool\n        E[Vote Extensions]\n        F[Prepare & Process Proposal]\n    end\nConsensus <--\x3e|ABCI| A[CometBFT]\n")),(0,o.yg)("p",null,":::Note\nABCI, Vote Extensions, and Prepare & Process Proposal are primitives of cometbft, V2 is not tied to these features, teams do not have to adhere to them if they implement their own consensus engine.\n:::"),(0,o.yg)("h3",{id:"state-transition-function"},"State Transition Function"),(0,o.yg)("p",null,"The state transition function is the component that handles the execution of transactions. It is responsible for calling the correct message handler for the transaction. The state transition function is stateless, it is handed a read only view of state and returns state changes, the changes returned can be handled by consensus in anyway needed. "),(0,o.yg)("p",null,"The state transition function interface is simple and meant to be as light weight as possible. This is the only interface that is required to be implemented by bespoke consensus engines."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-mermaid"},'graph TD    \n    subgraph STF[State Transition Function]\n        BR --\x3e DB\n        subgraph DB[DeliverBlock]\n            PB[PreBlock]\n            BB[BeginBlock]\n            DT["Deliver Transaction(s)"]\n            EB[EndBlock]\n        end\n        BR[BlockRequest]\n        Q[Query]\n        S[Simulate]\n        VT[Validate TX]\n    end\n    C --\x3e|Decoded Transactions| STF\n    DBR --\x3e STF\n    STF --\x3e |ChangeSets, Events, Transaction Results| C2\n    C2 --\x3e|Commit To DB| D\n\n    C[Consensus]\n    C2[Consensus]\n    D[DataBase]\n    DBR[DataBase Reader]\n')),(0,o.yg)("p",null,"State Transition function interface: "),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-go"},"type StateTransitionFunction[T transaction.Tx] interface {\n    // DeliverBlock executes a block of transactions.\n    DeliverBlock(\n        ctx context.Context,\n        block *server.BlockRequest[T],\n        state store.ReaderMap,\n    ) (blockResult *server.BlockResponse, newState store.WriterMap, err error)\n    \n    // ValidateTx validates a transaction.\n    ValidateTx(\n        ctx context.Context,\n        state store.ReaderMap,\n        gasLimit uint64,\n        tx T,\n    ) server.TxResult\n    \n    // Simulate executes a transaction in simulation mode.\n    Simulate(\n        ctx context.Context,\n        state store.ReaderMap,\n        gasLimit uint64,\n        tx T,\n    ) (server.TxResult, store.WriterMap)\n    \n    // Query executes a query on the application.\n    Query(\n        ctx context.Context,\n        state store.ReaderMap,\n        gasLimit uint64,\n        req transaction.Msg,\n    ) (transaction.Msg, error)\n}\n")),(0,o.yg)("h2",{id:"consequences"},"Consequences"),(0,o.yg)("p",null,"The design of the node comes with a number of tradeoffs."),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Maintenance cost can be the same as existing Baseapp as handling many go.mods is an overhead."),(0,o.yg)("li",{parentName:"ul"},"Modularity means different layers of abstractions, abstractions always have a cost. ")),(0,o.yg)("h3",{id:"backwards-compatibility"},"Backwards Compatibility"),(0,o.yg)("p",null,"The state machine was made to not affect modules that are not using the state transition function. If a user would like to migrate to v2 they will need to migrate to ",(0,o.yg)("inlineCode",{parentName:"p"},"appmodule.Environment")," from ",(0,o.yg)("inlineCode",{parentName:"p"},"sdk.Context"),".  ",(0,o.yg)("inlineCode",{parentName:"p"},"sdk.Context")," is a struct which is a global in the state machine, this design limits the concurrency. "),(0,o.yg)("p",null,"V2 will have a breaking changes in regards to how CometBFT handles certain fields in ABCI. Previously, the Cosmos SDK panicked and recovered in the case of out of gas, providing an error to CometBFT which we do not return in the new design. "),(0,o.yg)("p",null,"V2 only works with ",(0,o.yg)("inlineCode",{parentName:"p"},"Store/v2"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"IAVL V1")," can be used with ",(0,o.yg)("inlineCode",{parentName:"p"},"Store/v2"),". This allows chains to continue with existing databases. There will be a migration happening to convert the database to the separation of Storage and Commitment. Once the migration is completed the state machine will query information from the rawDB unless otherwise specified. "),(0,o.yg)("h3",{id:"positive"},"Positive"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Ability to add new features to the SDK without forking the entire repository."),(0,o.yg)("li",{parentName:"ul"},"Ability to create custom node configurations."),(0,o.yg)("li",{parentName:"ul"},"Reduced maintenance cost burden. "),(0,o.yg)("li",{parentName:"ul"},"State machine is more performant."),(0,o.yg)("li",{parentName:"ul"},"Isolated components allow for easier testing."),(0,o.yg)("li",{parentName:"ul"},"Allow the team to delete a lot of code in ",(0,o.yg)("inlineCode",{parentName:"li"},"github.com/cosmos/cosmos-sdk"),".")),(0,o.yg)("h3",{id:"negative"},"Negative"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Modularity and abstractions can be a burden.")),(0,o.yg)("h2",{id:"further-discussions"},"Further Discussions"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"After reducing the feature set of Cosmos SDK, we can more easily look into rewriting the core into rust. This is dependent on crosslang. ")),(0,o.yg)("h2",{id:"references"},"References"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"{reference link}")))}p.isMDXComponent=!0}}]);