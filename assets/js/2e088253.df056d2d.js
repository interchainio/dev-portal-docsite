"use strict";(self.webpackChunkdev_portal_docsite=self.webpackChunkdev_portal_docsite||[]).push([[40506],{15680:(e,n,t)=>{t.d(n,{xA:()=>c,yg:()=>y});var o=t(96540);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=o.createContext({}),p=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=p(e.components);return o.createElement(l.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},m=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(t),m=r,y=d["".concat(l,".").concat(m)]||d[m]||u[m]||a;return t?o.createElement(y,i(i({ref:n},c),{},{components:t})):o.createElement(y,i({ref:n},c))}));function y(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,i=new Array(a);i[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[d]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<a;p++)i[p]=t[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}m.displayName="MDXCreateElement"},19592:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var o=t(58168),r=(t(96540),t(15680));const a={},i="Vote Extensions",s={unversionedId:"docs/build/abci/vote-extensions",id:"docs/build/abci/vote-extensions",title:"Vote Extensions",description:"This section describes how the application can define and use vote extensions",source:"@site/cosmos-sdk/docs/build/abci/03-vote-extensions.md",sourceDirName:"docs/build/abci",slug:"/docs/build/abci/vote-extensions",permalink:"/dev-portal-docsite/cosmos-sdk/next/docs/build/abci/vote-extensions",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{},sidebar:"buildSidebar",previous:{title:"Process Proposal",permalink:"/dev-portal-docsite/cosmos-sdk/next/docs/build/abci/process-proposal"},next:{title:"CheckTx",permalink:"/dev-portal-docsite/cosmos-sdk/next/docs/build/abci/checktx"}},l={},p=[{value:"Extend Vote",id:"extend-vote",level:2},{value:"Verify Vote Extension",id:"verify-vote-extension",level:2},{value:"Vote Extension Propagation",id:"vote-extension-propagation",level:2},{value:"Recovery of injected Vote Extensions",id:"recovery-of-injected-vote-extensions",level:3},{value:"Vote Extensions on v2",id:"vote-extensions-on-v2",level:2},{value:"Extend Vote",id:"extend-vote-1",level:3},{value:"Verify Vote Extension",id:"verify-vote-extension-1",level:3},{value:"Prepare and Process Proposal",id:"prepare-and-process-proposal",level:3},{value:"Preblocker",id:"preblocker",level:3}],c={toc:p},d="wrapper";function u(e){let{components:n,...t}=e;return(0,r.yg)(d,(0,o.A)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"vote-extensions"},"Vote Extensions"),(0,r.yg)("admonition",{title:"Synopsis",type:"note"},(0,r.yg)("p",{parentName:"admonition"},"This section describes how the application can define and use vote extensions\ndefined in ABCI++.")),(0,r.yg)("h2",{id:"extend-vote"},"Extend Vote"),(0,r.yg)("p",null,"ABCI2.0 (colloquially called ABCI++) allows an application to extend a pre-commit vote with arbitrary data. This process does NOT have to be deterministic, and the data returned can be unique to the\nvalidator process. The Cosmos SDK defines ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/blob/v0.52.0-beta.1/types/abci.go#L26-L27"},(0,r.yg)("inlineCode",{parentName:"a"},"baseapp.ExtendVoteHandler")),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-go"},"type ExtendVoteHandler func(Context, *abci.ExtendVoteRequest) (*abci.ExtendVoteResponse, error)\n")),(0,r.yg)("p",null,"An application can set this handler in ",(0,r.yg)("inlineCode",{parentName:"p"},"app.go")," via the ",(0,r.yg)("inlineCode",{parentName:"p"},"baseapp.SetExtendVoteHandler"),"\n",(0,r.yg)("inlineCode",{parentName:"p"},"BaseApp")," option function. The ",(0,r.yg)("inlineCode",{parentName:"p"},"sdk.ExtendVoteHandler"),", if defined, is called during\nthe ",(0,r.yg)("inlineCode",{parentName:"p"},"ExtendVote")," ABCI method. Note, if an application decides to implement\n",(0,r.yg)("inlineCode",{parentName:"p"},"baseapp.ExtendVoteHandler"),", it MUST return a non-nil ",(0,r.yg)("inlineCode",{parentName:"p"},"VoteExtension"),". However, the vote\nextension can be empty. See ",(0,r.yg)("a",{parentName:"p",href:"https://docs.cometbft.com/v1.0/spec/abci/abci++_methods#extendvote"},"here"),"\nfor more details."),(0,r.yg)("p",null,"There are many decentralized censorship-resistant use cases for vote extensions.\nFor example, a validator may want to submit prices for a price oracle or encryption\nshares for an encrypted transaction mempool. Note, an application should be careful\nto consider the size of the vote extensions as they could increase latency in block\nproduction. See ",(0,r.yg)("a",{parentName:"p",href:"https://docs.cometbft.com/v1.0/references/qa/cometbft-qa-38#vote-extensions-testbed"},"here"),"\nfor more details."),(0,r.yg)("p",null,"Click ",(0,r.yg)("a",{parentName:"p",href:"https://docs.cosmos.network/main/build/abci/vote-extensions"},"here")," if you would like a walkthrough of how to implement vote extensions."),(0,r.yg)("h2",{id:"verify-vote-extension"},"Verify Vote Extension"),(0,r.yg)("p",null,"Similar to extending a vote, an application can also verify vote extensions from\nother validators when validating their pre-commits. For a given vote extension,\nthis process MUST be deterministic. The Cosmos SDK defines ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/blob/v0.52.0-beta.1/types/abci.go#L29-L31"},(0,r.yg)("inlineCode",{parentName:"a"},"sdk.VerifyVoteExtensionHandler")),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-go"},"type VerifyVoteExtensionHandler func(Context, *abci.VerifyVoteExtensionRequest) (*abci.VerifyVoteExtensionResponse, error)\n")),(0,r.yg)("p",null,"An application can set this handler in ",(0,r.yg)("inlineCode",{parentName:"p"},"app.go")," via the ",(0,r.yg)("inlineCode",{parentName:"p"},"baseapp.SetVerifyVoteExtensionHandler"),"\n",(0,r.yg)("inlineCode",{parentName:"p"},"BaseApp")," option function. The ",(0,r.yg)("inlineCode",{parentName:"p"},"sdk.VerifyVoteExtensionHandler"),", if defined, is called\nduring the ",(0,r.yg)("inlineCode",{parentName:"p"},"VerifyVoteExtension")," ABCI method. If an application defines a vote\nextension handler, it should also define a verification handler. Note, not all\nvalidators will share the same view of what vote extensions they verify depending\non how votes are propagated. See ",(0,r.yg)("a",{parentName:"p",href:"https://docs.cometbft.com/v1.0/spec/abci/abci++_methods#verifyvoteextension"},"here"),"\nfor more details."),(0,r.yg)("p",null,"Additionally, please keep in mind that performance can be degraded if vote extensions are too big (",(0,r.yg)("a",{parentName:"p",href:"https://docs.cometbft.com/v1.0/references/qa/cometbft-qa-38#vote-extensions-testbed"},"see vote extension testbed"),"), so we highly recommend a size validation in ",(0,r.yg)("inlineCode",{parentName:"p"},"VerifyVoteExtensions"),"."),(0,r.yg)("h2",{id:"vote-extension-propagation"},"Vote Extension Propagation"),(0,r.yg)("p",null,"The agreed upon vote extensions at height ",(0,r.yg)("inlineCode",{parentName:"p"},"H")," are provided to the proposing validator\nat height ",(0,r.yg)("inlineCode",{parentName:"p"},"H+1")," during ",(0,r.yg)("inlineCode",{parentName:"p"},"PrepareProposal"),". As a result, the vote extensions are\nnot natively provided or exposed to the remaining validators during ",(0,r.yg)("inlineCode",{parentName:"p"},"ProcessProposal"),".\nAs a result, if an application requires that the agreed upon vote extensions from\nheight ",(0,r.yg)("inlineCode",{parentName:"p"},"H")," are available to all validators at ",(0,r.yg)("inlineCode",{parentName:"p"},"H+1"),', the application must propagate\nthese vote extensions manually in the block proposal itself. This can be done by\n"injecting" them into the block proposal, since the ',(0,r.yg)("inlineCode",{parentName:"p"},"Txs")," field in ",(0,r.yg)("inlineCode",{parentName:"p"},"PrepareProposal"),"\nis just a slice of byte slices."),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"FinalizeBlock")," will ignore any byte slice that doesn't implement an ",(0,r.yg)("inlineCode",{parentName:"p"},"sdk.Tx"),", so\nany injected vote extensions will safely be ignored in ",(0,r.yg)("inlineCode",{parentName:"p"},"FinalizeBlock"),". For more\ndetails on propagation, see the ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/blob/main/docs/architecture/adr-064-abci-2.0.md#vote-extension-propagation--verification"},"ABCI++ 2.0 ADR"),"."),(0,r.yg)("h3",{id:"recovery-of-injected-vote-extensions"},"Recovery of injected Vote Extensions"),(0,r.yg)("p",null,"As stated before, vote extensions can be injected into a block proposal (along with\nother transactions in the ",(0,r.yg)("inlineCode",{parentName:"p"},"Txs")," field). The Cosmos SDK provides a pre-FinalizeBlock\nhook to allow applications to recover vote extensions, perform any necessary\ncomputation on them, and then store the results in the cached store. These results\nwill be available to the application during the subsequent ",(0,r.yg)("inlineCode",{parentName:"p"},"FinalizeBlock")," call."),(0,r.yg)("p",null,"An example of how a pre-FinalizeBlock hook could look like is shown below:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-go"},"app.SetPreBlocker(func(ctx sdk.Context, req *abci.RequestFinalizeBlock) error {\n    allVEs := []VE{} // store all parsed vote extensions here\n    for _, tx := range req.Txs {\n        // define a custom function that tries to parse the tx as a vote extension\n        ve, ok := parseVoteExtension(tx)\n        if !ok {\n            continue\n        }\n\n        allVEs = append(allVEs, ve)\n    }\n\n    // perform any necessary computation on the vote extensions and store the result\n    // in the cached store\n    result := compute(allVEs)\n    err := storeVEResult(ctx, result)\n    if err != nil {\n        return err\n    }\n\n    return nil\n})\n\n")),(0,r.yg)("p",null,"Then, in an app's module, the application can retrieve the result of the computation\nof vote extensions from the cached store:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-go"},"func (k Keeper) BeginBlocker(ctx context.Context) error {\n    // retrieve the result of the computation of vote extensions from the cached store\n    result, err := k.GetVEResult(ctx)\n    if err != nil {\n        return err\n    }\n\n    // use the result of the computation of vote extensions\n    k.setSomething(result)\n\n    return nil\n}\n")),(0,r.yg)("h2",{id:"vote-extensions-on-v2"},"Vote Extensions on v2"),(0,r.yg)("h3",{id:"extend-vote-1"},"Extend Vote"),(0,r.yg)("p",null,"In v2, the ",(0,r.yg)("inlineCode",{parentName:"p"},"ExtendVoteHandler")," function works in the same way as it does in v1,\nbut the implementation is passed as a server option when calling ",(0,r.yg)("inlineCode",{parentName:"p"},"cometbft.New"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-go"},'serverOptions.ExtendVoteHandler = CustomExtendVoteHandler()\n\nfunc CustomExtendVoteHandler() handlers.ExtendVoteHandler {\n    return func(ctx context.Context, rm store.ReaderMap, evr *v1.ExtendVoteRequest) (*v1.ExtendVoteResponse, error) {\n        return &v1.ExtendVoteResponse{\n            VoteExtension: []byte("BTC=1234567.89;height=" + fmt.Sprint(evr.Height)),\n        }, nil\n    }\n}\n')),(0,r.yg)("h3",{id:"verify-vote-extension-1"},"Verify Vote Extension"),(0,r.yg)("p",null,"Same as above:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-go"},"serverOptions.VerifyVoteExtensionHandler = CustomVerifyVoteExtensionHandler()\n\nfunc CustomVerifyVoteExtensionHandler() handlers.VerifyVoteExtensionHandler {\n    return  func(context.Context, store.ReaderMap, *abci.VerifyVoteExtensionRequest) (*abci.VerifyVoteExtensionResponse, error) {\n        return &abci.VerifyVoteExtensionResponse{}, nil\n    }\n}\n\n")),(0,r.yg)("h3",{id:"prepare-and-process-proposal"},"Prepare and Process Proposal"),(0,r.yg)("p",null,"These are also passed in as server options when calling ",(0,r.yg)("inlineCode",{parentName:"p"},"cometbft.New"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-go"},"serverOptions.PrepareProposalHandler = CustomPrepareProposal[T]()\nserverOptions.ProcessProposalHandler = CustomProcessProposalHandler[T]()\n")),(0,r.yg)("p",null,"The PrepareProposal handler can be used to inject vote extensions into the block proposal\nby using the ",(0,r.yg)("inlineCode",{parentName:"p"},"cometbft.RawTx")," util function, which allows passing in arbitrary bytes."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-go"},'func CustomPrepareProposal[T transaction.Tx]() handlers.PrepareHandler[T] {\n    return func(ctx context.Context, app handlers.AppManager[T], codec transaction.Codec[T], req *v1.PrepareProposalRequest, chainID string) ([]T, error) {\n        var txs []T\n        for _, tx := range req.Txs {\n            decTx, err := codec.Decode(tx)\n            if err != nil {\n                continue\n            }\n\n            txs = append(txs, decTx)\n        }\n\n        // "Process" vote extensions (we\'ll just inject all votes)\n        injectedTx, err := json.Marshal(req.LocalLastCommit)\n        if err != nil {\n            return nil, err\n        }\n\n        // put the injected tx into the first position\n        txs = append([]T{cometbft.RawTx(injectedTx).(T)}, txs...)\n\n        return txs, nil\n    }\n}\n')),(0,r.yg)("p",null,"The ProcessProposal handler can be used to recover the vote extensions from the first transaction\nand perform any necessary verification on them. In the example below we also use the\n",(0,r.yg)("inlineCode",{parentName:"p"},"cometbft.ValidateVoteExtensions"),' util to verify the signature of the vote extensions;\nthis function takes a "validatorStore" function that returns the public key of a validator\ngiven its consensus address. In the example we use the default staking module to get the\nvalidators.'),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-go"},'func CustomProcessProposalHandler[T transaction.Tx]() handlers.ProcessHandler[T] {\n    return func(ctx context.Context, am handlers.AppManager[T], c transaction.Codec[T], req *v1.ProcessProposalRequest, chainID string) error {\n        // Get all vote extensions from the first tx\n\n        injectedTx := req.Txs[0]\n        var voteExts v1.ExtendedCommitInfo\n        if err := json.Unmarshal(injectedTx, &voteExts); err != nil {\n            return err\n        }\n\n        // Get validators from the staking module\n        res, err := am.Query(\n            ctx,\n            0,\n            &staking.QueryValidatorsRequest{},\n        )\n        if err != nil {\n            return err\n        }\n\n        validatorsResponse := res.(*staking.QueryValidatorsResponse)\n        consAddrToPubkey := map[string]cryptotypes.PubKey{}\n\n        for _, val := range validatorsResponse.GetValidators() {\n            cv := val.ConsensusPubkey.GetCachedValue()\n            if cv == nil {\n                return fmt.Errorf("public key cached value is nil")\n            }\n\n            cpk, ok := cv.(cryptotypes.PubKey)\n            if ok {\n                consAddrToPubkey[string(cpk.Address().Bytes())] = cpk\n            } else {\n                return fmt.Errorf("invalid public key type")\n            }\n        }\n\n        // First verify that the vote extensions injected by the proposer are correct\n        if err := cometbft.ValidateVoteExtensions(\n            ctx,\n            am,\n            chainID,\n            func(ctx context.Context, b []byte) (cryptotypes.PubKey, error) {\n                if _, ok := consAddrToPubkey[string(b)]; !ok {\n                    return nil, fmt.Errorf("validator not found")\n                }\n                return consAddrToPubkey[string(b)], nil\n            },\n            voteExts,\n            req.Height,\n            &req.ProposedLastCommit,\n        ); err != nil {\n            return err\n        }\n\n        // TODO: do something with the vote extensions\n\n        return nil\n    }\n}\n')),(0,r.yg)("h3",{id:"preblocker"},"Preblocker"),(0,r.yg)("p",null,"In v2, the ",(0,r.yg)("inlineCode",{parentName:"p"},"PreBlocker")," function works in the same way as it does in v1. However, it is\nnow passed in as an option to ",(0,r.yg)("inlineCode",{parentName:"p"},"appbuilder.Build"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-go"},"app.App, err = appBuilder.Build(runtime.AppBuilderWithPreblocker(\n    func(ctx context.Context, txs []T) error {\n        // to recover the vote extension use\n        voteExtBz := txs[0].Bytes()\n        err := doSomethingWithVoteExt(voteExtBz)\n        return err\n    },\n))\n")))}u.isMDXComponent=!0}}]);